<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VAASTAV - the city of hopes</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <script>
        function toggleInfo(id) {
            var section = document.getElementById(id);
            section.style.display = section.style.display === "block" ? "none" : "block";
        }
    </script>
</head>
<body>
    <header>
        <h1>Welcome to Vastav</h1>
        <p>Your gateway to knowledge, innovation, and well-being.</p>
    </header>

    <nav>
        <button class="button" style ="color: black;" onclick="toggleInfo('course-intro')">Course Introduction</button>
        
    </nav>

    <section id="course-intro" style="display: none;">
          <h2>Course Introduction</h2>
  <p>
        The "Design and Analysis of Algorithms" course emphasizes understanding, designing, and evaluating algorithms to solve computational problems effectively. It delves into topics such as recursion, graph algorithms, sorting and searching, and advanced data structures like trees and heaps. Students gain skills in analyzing algorithm efficiency in terms of time and space complexity, applying these methods to real-world problems, and building a strong foundation for tackling advanced computing challenges.
    </p>
 <br>   <h2>What kind of data structures and algorithms have you studied?</h2>

    <h3>Data Structures:</h3>
    <ul>
        <li><strong>Basic Structures:</strong> Arrays, Stacks, Queues, Linked Lists</li>
        <li><strong>Intermediate Structures:</strong> Trees, Graphs, Heaps</li>
        <li><strong>Advanced Structures:</strong> Tries, Fenwick Trees, Segment Trees, Skip Lists</li>
    </ul>

    <h3>Algorithms:</h3>
    <ul>
        <li><strong>Sorting and Searching:</strong> Organizing data with Bubble Sort, Quick Sort, Merge Sort, and searching with Binary Search, KMP Algorithm</li>
        <li><strong>Graph Algorithms:</strong> Shortest path algorithms (Dijkstra’s, Bellman-Ford) and Minimum Spanning Trees (Prim’s, Kruskal’s)</li>
        <li><strong>Pathfinding:</strong> Algorithms for route determination, such as Floyd-Warshall</li>
<li><strong>Optimization Problems:</strong> Solutions for Knapsack, Travelling Salesperson Problem, and Huffman Coding</li>
        <li><strong>Recursion and Backtracking:</strong> Function-based problem-solving (e.g., N-Queens Problem)</li>
        <li><strong>String Matching:</strong> Pattern searching with Rabin-Karp, Boyer-Moore, and Brute Force algorithms</li>
        <li><strong>Divide and Conquer:</strong> Techniques like Merge Sort and Strassen’s Matrix Multiplication</li>
        <li><strong>Dynamic Programming:</strong> Breaking problems into overlapping subproblems (e.g., Fibonacci, Longest Common Subsequence)</li>
        <li><strong>Undecidability:</strong> Exploring problems with no algorithmic solutions (e.g., Halting Problem)</li>
    </ul>

   <br> <h2>How do you connect the course with real-time applications?</h2>
    <ul>
        <li><strong>Graph Algorithms:</strong> Employ Dijkstra's or Kruskal's algorithms to optimize routes in transportation networks or telecommunication systems.</li>
        <li><strong>Sorting and Searching:</strong> Use efficient algorithms for inventory management and fast product searches in e-commerce platforms.</li>
        <li><strong>Data Structures:</strong> Utilize heaps, trees, and hash tables for database indexing and real-time data retrieval systems like caching.</li>
        <li><strong>Optimization Problems:</strong> Address real-world scenarios, such as resource allocation in project management, using the Knapsack problem.</li>
    </ul>
    </section>
       <section id="PPS">
        <h2>Problem Statement</h2>
        <p>data-driven urban planning system for smart cities with minimal vehicle usage. It will use efficient data structures and algorithms to optimize transportation, resource management, and governance while promoting environmental sustainability and enhancing tourism opportunities. The system will focus on leveraging real-time data and predictive analytics to ensure efficient, eco-friendly city operations.</p>  </section>
    </section>

    <section id="More Information">
       <header>
        <h1>VAASTAV: Journey On with Conviction</h1>
    </header>

        <h2><b>A City for Tomorrow</b></h2>
        <p>VAASTAV is built with tomorrow in mind, designed to bring a better future today. At the heart of the city lies its people, with every element crafted to empower the community. Here, every doorway opens to new learning opportunities, every pillar supports cutting-edge innovations, and every path leads toward holistic well-being.</p>

        <h2><b>Core Values: A Mindful Social Framework</b></h2>
        <p>VAASTAV is not just a place, but a community built on values that matter. With a strong foundation in collaboration, conservation, and coexistence, the city reflects a commitment to the environment and social harmony.</p>
        <h2><b>A Green, People-Centric Future</b></h2>
        <p>Our city is rich in green promises, creating a sustainable environment where nature and people coexist seamlessly. VAASTAV isn’t just designed for the future; it is designed by and for the people, making it a destination like no other. The city inspires a new way of life, focused on innovation, sustainability, and inclusivity.</p>
        <h2><b>Strategic Location: Connecting to the World</b></h2>
        <p><b>Well-Connected, Convenient, and Accessible</b></p>
        <p>VAASTAV enjoys a prime location strategically positioned between <b>Doddaballapur</b> and <b>Dobbaspet</b>, ensuring easy access to key regions. Just <b>45 minutes from Kempegowda International Airport</b>, the city is well-connected by major transportation routes.</p>

        <ul>
            <li><b>Bangalore-Hubli-Mumbai Express Rail Route</b>: Ensuring seamless rail connectivity to critical hubs.</li>
            <li><b>National Highways 44 and 648</b>: Providing excellent road access to and from the city.</li>
        </ul>

        <p>With this connectivity, VAASTAV is perfectly situated for regional and global growth, making it an ideal place for business, innovation, and community.</p>
    </section>
</section>

    <section id="city-map">`
        <h1>City Map</h1>
        <p>Explore the layout of VAASTAV.</p>
        <img src="./projdaa.jpg" alt="VAASTAV Map" style="width: 100%; max-width: 600px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);">

    </section>

  <nav>
    <button class="button" style ="color: black;" onclick="toggleInfo('business-ideas')">Business Ideas</button>
  </nav>
     <section id="business-ideas" style="display: none;">
        <h2>Business Ideas</h2>
       <table>
    <thead>
        <tr>
            <th>SLNO</th>
            <th>Business Case</th>
            <th>Description</th>
            <th>Owner</th>
            <th>Tools</th>
        </tr>
    </thead>
    <tbody>
        <tr><td>1</td><td>Optimal Tourist Routes</td><td>Route optimization for tourists.</td><td>Varun S T</td><td>Graphs</td></tr>
        <tr><td>2</td><td>Menu Item Sorting</td><td>Sort menus by price/popularity.</td><td>Vishal U H</td><td>Quick Sort</td></tr>
        <tr><td>3</td><td>Traffic Monitoring</td><td>Analyze intersection traffic density.</td><td>Saif Ali</td><td>BFS, DFS</td></tr>
        <tr><td>4</td><td>Waste Management</td><td>Efficient waste collection routes.</td><td>Suleman A</td><td>Dijkstra's</td></tr>
        <tr><td>5</td><td>Water Usage</td><td>Residential water analysis.</td><td>Vishal and Varun</td><td>Time Series</td></tr>
        <tr><td>6</td><td>Internet Connectivity</td><td>Optimize city-wide Wi-Fi.</td><td>Saif and Suleman</td><td>Minimum Spanning Tree</td></tr>
    </tbody>
</table>

         <h1><strong>Introduction to the Business Cases</strong></h1>

  <br>  <h2><strong>1. Predicting Optimal Tourist Routes (Varun S T)</strong></h2>
    <p><strong>This initiative focuses on developing a system that leverages real-time data like traffic conditions, crowd density, and user preferences to recommend ideal travel routes for tourists.</strong> Using graph-based algorithms, the system ensures that visitors have a seamless and enjoyable experience while reducing the pressure on popular tourist locations. By optimizing routes, it also supports sustainable urban tourism and enhances the visibility of lesser-known attractions.</p>

    <h3><strong>Sustainable Goals:</strong></h3>
    <ul>
        <li><strong>Distributes tourism traffic evenly to prevent overcrowding and environmental degradation at popular sites.</strong></li>
        <li><strong>Encourages the use of sustainable transport modes, reducing the carbon footprint of travel.</strong></li>
        <li><strong>Enhances accessibility to cultural and natural heritage sites, fostering inclusive tourism.</strong></li>
    </ul>

    <h3><strong>Challenges in Implementation:</strong></h3>
    <ul>
        <li><strong>Integrating diverse data sources like GPS, weather, and user preferences into a unified system.</strong></li>
        <li><strong>Balancing system performance and accuracy for real-time route optimization.</strong></li>
        <li><strong>Ensuring privacy and security while collecting and processing user data.</strong></li>
    </ul>

    <br><h2><strong>2. Sorting Menu Items (Vishal U H)</strong></h2>
    <p><strong>Sorting menu items efficiently is crucial for e-commerce and digital platforms in food and retail industries.</strong> This system uses quick sort and array structures to organize items based on price or popularity, offering a streamlined and intuitive interface for users. By dynamically updating sorting criteria based on real-time data, the solution ensures an enhanced customer experience and supports better decision-making.</p>

    <h3><strong>Sustainable Goals:</strong></h3>
    <ul>
        <li><strong>Promotes informed consumer choices by highlighting affordable or eco-friendly options.</strong></li>
        <li><strong>Reduces decision-making time, indirectly contributing to efficient resource utilization in retail and food services.</strong></li>
        <li><strong>Supports sustainable consumption patterns by surfacing locally sourced or seasonal items.</strong></li>
    </ul>

    <h3><strong>Challenges in Implementation:</strong></h3>
    <ul>
        <li><strong>Adapting to changes in popularity or pricing in real-time without significant delays.</strong></li>
        <li><strong>Scaling efficiently for platforms with extensive and diverse catalogs.</strong></li>
        <li><strong>Addressing algorithm biases to ensure fair representation of all menu items.</strong></li>
    </ul>

    <br><h2><strong>3. Monitoring Traffic Flow (Saif Ali)</strong></h2>
    <p><strong>Managing traffic density at critical intersections is essential for promoting vehicle-free smart cities.</strong> This case employs graph traversal algorithms like BFS and DFS to analyze traffic patterns, identify bottlenecks, and propose alternate routes. The solution supports proactive traffic management, ensuring smoother flow and reducing environmental impact.</p>

    <h3><strong>Sustainable Goals:</strong></h3>
    <ul>
        <li><strong>Minimizes emissions by reducing idle times at congested intersections.</strong></li>
        <li><strong>Supports active commuting methods like walking and cycling by optimizing pathways.</strong></li>
        <li><strong>Enhances urban mobility while aligning with goals for sustainable cities and communities.</strong></li>
    </ul>

    <h3><strong>Challenges in Implementation:</strong></h3>
    <ul>
        <li><strong>High dependency on IoT infrastructure for accurate data collection.</strong></li>
        <li><strong>Real-time analysis of large datasets from sensors and cameras.</strong></li>
        <li><strong>Overcoming resistance from commuters used to traditional traffic systems.</strong></li>
    </ul>

    <br><h2><strong>4. Optimizing Waste Management Routes (Suleman A)</strong></h2>
    <p><strong>Efficient waste collection is vital for urban hygiene and sustainability.</strong> This system applies Dijkstra's Algorithm to determine optimal routes for waste collection vehicles, minimizing fuel consumption and travel time. It not only reduces operational costs but also contributes to lower emissions, supporting green city initiatives.</p>

    <h3><strong>Sustainable Goals:</strong></h3>
    <ul>
        <li><strong>Lowers fuel consumption and carbon emissions by streamlining waste collection routes.</strong></li>
        <li><strong>Reduces operational costs, enabling reinvestment in other sustainability initiatives.</strong></li>
        <li><strong>Prevents missed waste pickups, promoting cleaner neighborhoods and efficient waste management.</strong></li>
    </ul>

    <h3><strong>Challenges in Implementation:</strong></h3>
    <ul>
        <li><strong>Handling dynamic changes like roadblocks or unexpected waste accumulation.</strong></li>
        <li><strong>Collecting and updating accurate data on waste generation across neighborhoods.</strong></li>
        <li><strong>Ensuring system compatibility with existing waste management infrastructure.</strong></li>
    </ul>

    <br><h2><strong>5. Monitoring Water Usage in Residential Areas (Varun & Vishal)</strong></h2>
    <p><strong>Water conservation is a critical concern in urban planning.</strong> This system tracks and analyzes residential water usage patterns using time-series analysis. By identifying trends and irregularities, it provides actionable insights for policymakers and promotes responsible water consumption among residents.</p>

    <h3><strong>Sustainable Goals:</strong></h3>
    <ul>
        <li><strong>Identifies wasteful water usage patterns, supporting conservation efforts.</strong></li>
        <li><strong>Promotes equitable water distribution across neighborhoods.</strong></li>
        <li><strong>Aligns with SDG Goal 6: Clean Water and Sanitation by fostering efficient water use.</strong></li>
    </ul>

    <h3><strong>Challenges in Implementation:</strong></h3>
    <ul>
        <li><strong>Collecting accurate and granular data without invading privacy.</strong></li>
        <li><strong>Analyzing seasonal or situational fluctuations in water usage.</strong></li>
        <li><strong>Encouraging residents to adopt water-saving practices based on insights.</strong></li>
    </ul>

   <br> <h2><strong>6. Optimizing City-Wide Internet Connectivity (Saif & Suleman)</strong></h2>
    <p><strong>Reliable internet connectivity is foundational to smart cities.</strong> This initiative maps and optimizes the placement of Wi-Fi hotspots using minimum spanning tree algorithms. By ensuring high-speed connectivity and minimizing redundant infrastructure, the system enhances digital inclusivity and supports the city's technological growth.</p>

    <h3><strong>Sustainable Goals:</strong></h3>
    <ul>
        <li><strong>Ensures equitable access to internet resources, bridging the digital divide.</strong></li>
        <li><strong>Reduces infrastructure redundancy, supporting efficient resource utilization.</strong></li>
        <li><strong>Promotes digital inclusion, enabling access to e-services for all city residents.</strong></li>
    </ul>

    <h3><strong>Challenges in Implementation:</strong></h3>
    <ul>
        <li><strong>Balancing high-speed connectivity with cost-effective deployment of Wi-Fi hotspots.</strong></li>
        <li><strong>Addressing challenges in mapping dense urban areas with complex layouts.</strong></li>
        <li><strong>Ensuring network reliability during peak usage hours or adverse conditions.</strong></li>
    </ul>
    </section>
    <section>
      <br><h2>Team Members</h2>

<!-- Vicky -->
<br>
<button class="button" style ="color: black;" onclick="toggleInfo('vicky-reflections')">01fe23bci - 223 - Vikneshwaran Marimuthu</button><br>
<section id="vicky-reflections" style="display: none;">
    <h2>Course Reflections - Vikneshwaran Marimuthu</h2>
    <ol>
        <h2>Question 1: Challenges in Learning/Understanding the Above Concepts</h2>
        <h3>Time Commitment</h3>
        <p>
            Learning how to analyze and construct <b>graphs</b> requires substantial time commitment, as understanding various algorithms like 
            <strong>DFS, BFS, and shortest path</strong> requires continuous practice and applying them to different scenarios. Implementing 
            graph algorithms, visualizing data, and optimizing algorithms are time-consuming but necessary to build a deep understanding.
        </p>

        <h3>Complexity of Graph Algorithms</h3>
        <p>
            The theoretical aspects of <b>graph algorithms</b> such as shortest path and connectivity tests can be overwhelming. 
            The challenge lies in understanding both the <b>theory</b> and <b>implementation</b> intricacies of various algorithms, such as 
            how DFS differs from BFS and when to use specific traversal methods.
        </p>

        <h2>Question 2: Challenges in Correlating with Real-World Applications</h2>
        <h3>Graph Representation</h3>
        <p>
            Translating complex <b>real-world problems</b> into a graph representation can be tricky. For example, modeling a social network, 
            transportation systems, or recommendation engines as graphs requires careful abstraction and simplification of real-world data.
        </p>

        <h3>Scalability Issues</h3>
        <p>
            Real-world applications, especially in social networks and large-scale databases, require scalable graph algorithms that can handle large volumes of data. 
            This presents the challenge of developing <b>efficient algorithms</b> that perform well even with millions of nodes and edges.
        </p>

        <h2>Answer 3: Determining the Most Efficient Approach/Design Techniques</h2>
        <h3>Optimizing Traversal Algorithms</h3>
        <p>
            Optimizing graph traversal algorithms like <strong>DFS</strong> and <strong>BFS</strong> is essential in real-world applications, such as finding the 
            shortest path in a routing system. Tailoring these algorithms to minimize computation, such as using <b>memoization</b> or <b>dynamic programming</b>, 
            can greatly enhance efficiency in large-scale scenarios.
        </p>
    </ol>
</section>

<!-- Vaishnavi -->
<br>
<button class="button" style ="color: black;" onclick="toggleInfo('vaishnavi-reflections')">01fe23bci013 - 203 - Vaishnavi</button><br>
<section id="vaishnavi-reflections" style="display: none;">
    <h2>Course Reflections - Vaishnavi</h2>
    <ol>
        <h2>Question 1: Challenges in Learning/Understanding the Above Concepts</h2>
        <h3>Time Complexity</h3>
        <p>
            Learning <b>Quick Sort</b> involved understanding not just the algorithm but also its time complexity in different scenarios, such as 
            best, average, and worst cases. The challenge is in mastering how the pivot selection and partitioning work and how to optimize them.
        </p>

        <h3>Recursive Nature</h3>
        <p>
            One of the hardest parts of Quick Sort is understanding its recursive nature, especially when working with large input sizes. The 
            complexity of visualizing recursive calls and managing base cases can be tricky.
        </p>

        <h2>Question 2: Challenges in Correlating with Real-World Applications</h2>
        <h3>Performance in Practice</h3>
        <p>
            In real-world applications, sorting large datasets efficiently is essential, but Quick Sort’s performance can degrade to O(n^2) in the 
            worst case. Ensuring that <b>randomized Quick Sort</b> or other optimizations are used to avoid this drawback is a challenge in practical 
            implementations.
        </p>

        <h3>Choice of Sorting Algorithms</h3>
        <p>
            Deciding when to use Quick Sort over other algorithms, such as Merge Sort or Heap Sort, can be difficult. Factors like input size, 
            data distribution, and whether memory efficiency is a priority should influence the choice.
        </p>

        <h2>Answer 3: Determining the Most Efficient Approach/Design Techniques</h2>
        <h3>Choosing the Right Pivot</h3>
        <p>
            The efficiency of Quick Sort largely depends on selecting the right pivot. To optimize it, techniques like <strong>median-of-three</strong> 
            or choosing a random pivot can help avoid the worst-case performance and ensure that the algorithm remains efficient in practice.
        </p>
    </ol>
</section>

<!-- Mudassir -->
<br>
<button class="button" style ="color: black;" onclick="toggleInfo('mudassir-reflections')">01fe23bci089 - 263 - Mudassir</button><br>
<section id="mudassir-reflections" style="display: none;">
    <h2>Course Reflections - Mudassir</h2>
    <ol>
        <h2>Question 1: Challenges in Learning/Understanding the Above Concepts</h2>
        <h3>Graph Theory Fundamentals</h3>
        <p>
            Learning <b>Graph Traversals</b> like BFS and DFS was initially overwhelming, as it required understanding graph theory fundamentals 
            and the subtle differences between the two algorithms, especially in how they explore graph structures.
        </p>

        <h3>Edge Cases in Traversal</h3>
        <p>
            Handling edge cases, such as disconnected graphs or graphs with cycles, added complexity to the BFS and DFS algorithms. Understanding 
            how to modify the traversal to handle these situations efficiently was a challenge.
        </p>

        <h2>Question 2: Challenges in Correlating with Real-World Applications</h2>
        <h3>Dynamic Data</h3>
        <p>
            Real-world graphs, such as social networks, are dynamic, meaning nodes and edges change over time. Applying BFS and DFS in such 
            dynamic contexts requires extra thought on how to adapt the algorithms for real-time data.
        </p>

        <h3>Scalability of BFS and DFS</h3>
        <p>
            When working with large graphs in applications like network routing or web crawling, ensuring that BFS and DFS can scale to handle 
            millions of nodes and edges is a major challenge. Optimizations such as pruning and avoiding unnecessary recursions are essential.
        </p>

        <h2>Answer 3: Determining the Most Efficient Approach/Design Techniques</h2>
        <h3>Hybrid Algorithms</h3>
        <p>
            In practice, combining BFS and DFS with other algorithms, like Dijkstra’s or A*, can yield efficient solutions to pathfinding 
            and network analysis problems. The ability to choose the appropriate traversal method based on the problem at hand is key to optimizing performance.
        </p>
    </ol>
</section>

<!-- Tejas -->
<br>
<button class="button" style ="color: black;" onclick="toggleInfo('tejas-reflections')">01fe23bci052 - 260 - Tejas</button><br>
<section id="tejas-reflections" style="display: none;">
    <h2>Course Reflections - Tejas</h2>
    <ol>
        <h2>Question 1: Challenges in Learning/Understanding the Above Concepts</h2>
        <h3>Complexity of Algorithms</h3>
        <p>
            The concepts behind <b>Dijkstra’s Algorithm</b> and <b>Minimum Spanning Tree</b> were initially difficult to understand, as they 
            require a solid understanding of greedy algorithms and graph theory. Understanding how each algorithm ensures optimality and 
            the trade-offs involved in their use was challenging.
        </p>

        <h3>Optimal Substructure</h3>
        <p>
            Dijkstra’s and Minimum Spanning Tree both require a deep understanding of the principle of <b>optimal substructure</b>, which 
            was an abstract concept to grasp initially. The challenge was in understanding how each step contributes to the overall solution.
        </p>

        <h2>Question 2: Challenges in Correlating with Real-World Applications</h2>
        <h3>Application in Networking</h3>
        <p>
            Implementing Dijkstra's algorithm for real-world applications like <b>network routing</b> can be tricky, especially when there 
            are dynamic changes in the network. The real-time application of these algorithms to reroute traffic is a challenge in dynamic systems.
        </p>

        <h3>Handling Large-Scale Graphs</h3>
        <p>
            For large-scale graphs, like those encountered in telecommunications or transportation systems, the performance of algorithms like 
            Minimum Spanning Tree needs to be optimized. Choosing between Prim's or Kruskal’s algorithms depends on the graph’s characteristics.
        </p>

        <h2>Answer 3: Determining the Most Efficient Approach/Design Techniques</h2>
        <h3>Heuristic Optimization</h3>
        <p>
            Optimizing Dijkstra’s algorithm with heuristics, such as A*, allows for faster solutions when finding the shortest path in large, 
            complex networks. This hybrid approach offers a way to balance between optimality and performance.
        </p>
    </ol>
</section>

<!-- Shreya -->
<br>
<button class="button" style ="color: black;" onclick="toggleInfo('shreya-reflections')">01fe23bci016 - 258 - Shreya</button><br>
<section id="shreya-reflections" style="display: none;">
    <h2>Course Reflections - Shreya</h2>
    <ol>
        <h2>Question 1: Challenges in Learning/Understanding the Above Concepts</h2>
        <h3>Understanding Time Series Data</h3>
        <p>
            Learning about <b>Time Series Analysis</b> was challenging because it required understanding both statistical methods and 
            machine learning approaches. Recognizing patterns and trends in sequential data and predicting future values involves mastering complex 
            mathematical concepts.
        </p>

        <h3>Real-Time Data Processing</h3>
        <p>
            Processing real-time data for applications like stock market prediction or weather forecasting involves challenges in handling 
            noisy and incomplete data. Efficiently analyzing such time series data in real-time requires both specialized algorithms and 
            domain-specific knowledge.
        </p>

        <h2>Question 2: Challenges in Correlating with Real-World Applications</h2>
        <h3>Forecasting with Noise</h3>
        <p>
            Real-world time series data often contains a lot of noise. Filtering out irrelevant data and forecasting future trends becomes 
            difficult when the data is not clean. Ensuring that the model works in real-world conditions, even with imperfect data, is a major challenge.
        </p>

        <h3>Complexity of Time Series Models</h3>
        <p>
            Models like ARIMA and LSTM require a strong understanding of both theory and practical application. The challenge is in 
            selecting the right model for the specific type of time series data and ensuring that the model can handle both short-term and 
            long-term trends effectively.
        </p>

        <h2>Answer 3: Determining the Most Efficient Approach/Design Techniques</h2>
        <h3>Feature Engineering for Time Series</h3>
        <p>
            Effective feature engineering is key to time series prediction. By transforming raw data into meaningful features, like seasonal 
            variations or trend components, the performance of models can be significantly improved.
        </p>
    </ol>
</section>

<</section>
 <nav>
    <button class="button" style ="color: black;" onclick="toggleInfo('code-ideas')">C++ CODE</button>
  </nav>
     <section id="code-ideas" style="display: none;">
        <h2>IMPLEMENTATION OF CODE </h2>
       

    <pre><code>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;numeric&gt; // For accumulate function
#include &lt;climits&gt; // For INT_MAX

using namespace std;

// Function for Optimal Tourist Routes (Graphs)
void optimalTouristRoutes() {
    cout &lt;&lt; "Optimal Tourist Routes using Graphs\n";
    int n;
    cout &lt;&lt; "Enter the number of nodes: ";
    cin &gt;&gt; n;

    vector&lt;vector&lt;int&gt;&gt; graph(n, vector&lt;int&gt;(n, 0));

    cout &lt;&lt; "Enter the adjacency matrix (distance between nodes):\n";
    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            cin &gt;&gt; graph[i][j];
        }
    }

    cout &lt;&lt; "Optimal route (example): 0 -&gt; 1 -&gt; 3 -&gt; 2\n";
}

// Function for Menu Item Sorting (Quick Sort)
void menuItemSorting() {
    cout &lt;&lt; "Menu Item Sorting by Price or Popularity\n";
    int n;
    cout &lt;&lt; "Enter the number of menu items: ";
    cin &gt;&gt; n;

    vector&lt;pair&lt;string, int&gt;&gt; menu;
    for (int i = 0; i &lt; n; ++i) {
        string item;
        int price;
        cout &lt;&lt; "Enter item name and price: ";
        cin &gt;&gt; item &gt;&gt; price;
        menu.emplace_back(item, price);
    }

    sort(menu.begin(), menu.end(), [](pair&lt;string, int&gt; a, pair&lt;string, int&gt; b) {
        return a.second &lt; b.second; // Sort by price (ascending)
    });

    cout &lt;&lt; "Sorted Menu:\n";
    for (auto item : menu) {
        cout &lt;&lt; item.first &lt;&lt; " - $" &lt;&lt; item.second &lt;&lt; "\n";
    }
}

// Function for Traffic Monitoring (BFS)
void trafficMonitoring() {
    cout &lt;&lt; "Traffic Monitoring using BFS\n";
    int n;
    cout &lt;&lt; "Enter the number of nodes: ";
    cin &gt;&gt; n;

    vector&lt;vector&lt;int&gt;&gt; graph(n, vector&lt;int&gt;(n, 0));

    cout &lt;&lt; "Enter the adjacency matrix (1 for connected, 0 for not connected):\n";
    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            cin &gt;&gt; graph[i][j];
        }
    }

    vector&lt;bool&gt; visited(n, false);
    queue&lt;int&gt; q;
    q.push(0);
    visited[0] = true;
    cout &lt;&lt; "BFS Order: ";
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout &lt;&lt; node &lt;&lt; " ";
        for (int i = 0; i &lt; n; ++i) {
            if (graph[node][i] == 1 &amp;&amp; !visited[i]) {
                visited[i] = true;
                q.push(i);
            }
        }
    }
    cout &lt;&lt; "\n";
}

// Function for Waste Management (Dijkstra's)
void wasteManagement() {
    cout &lt;&lt; "Waste Management Route Optimization using Dijkstra's\n";
    int n, e;
    cout &lt;&lt; "Enter the number of nodes and edges: ";
    cin &gt;&gt; n &gt;&gt; e;

    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph(n);
    cout &lt;&lt; "Enter the edges (format: node1 node2 weight):\n";
    for (int i = 0; i &lt; e; ++i) {
        int u, v, w;
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        graph[u].emplace_back(v, w);
    }

    vector&lt;int&gt; dist(n, INT_MAX);
    dist[0] = 0;
    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;&gt;&gt; pq;
    pq.push({0, 0});

    while (!pq.empty()) {
        auto [cost, node] = pq.top();
        pq.pop();
        for (auto [next, weight] : graph[node]) {
            if (dist[next] &gt; cost + weight) {
                dist[next] = cost + weight;
                pq.push({dist[next], next});
            }
        }
    }

    cout &lt;&lt; "Shortest distances from Node 0: ";
    for (int d : dist) cout &lt;&lt; d &lt;&lt; " ";
    cout &lt;&lt; "\n";
}

// Function for Water Usage Analysis (Time Series)
void waterUsageAnalysis() {
    cout &lt;&lt; "Water Usage Analysis using Time Series\n";
    int n;
    cout &lt;&lt; "Enter the number of usage entries: ";
    cin &gt;&gt; n;

    vector&lt;int&gt; usage(n);
    cout &lt;&lt; "Enter the water usage data:\n";
    for (int i = 0; i &lt; n; ++i) {
        cin &gt;&gt; usage[i];
    }

    cout &lt;&lt; "Average Usage: "
         &lt;&lt; accumulate(usage.begin(), usage.end(), 0) / usage.size()
         &lt;&lt; "\n";
}

// Function for Internet Connectivity (Minimum Spanning Tree)
void internetConnectivity() {
    cout &lt;&lt; "Internet Connectivity Optimization using MST\n";
    int n;
    cout &lt;&lt; "Enter the number of nodes: ";
    cin &gt;&gt; n;

    vector&lt;vector&lt;int&gt;&gt; graph(n, vector&lt;int&gt;(n, 0));
    cout &lt;&lt; "Enter the adjacency matrix (cost of edges):\n";
    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            cin &gt;&gt; graph[i][j];
        }
    }

    vector&lt;int&gt; key(n, INT_MAX);
    vector&lt;bool&gt; inMST(n, false);
    key[0] = 0;
    int result = 0;

    for (int i = 0; i &lt; n; ++i) {
        int u = -1;
        for (int v = 0; v &lt; n; ++v) {
            if (!inMST[v] &amp;&amp; (u == -1 || key[v] &lt; key[u])) {
                u = v;
            }
        }

        inMST[u] = true;
        result += key[u];
        for (int v = 0; v &lt; n; ++v) {
            if (graph[u][v] &amp;&amp; !inMST[v] &amp;&amp; graph[u][v] &lt; key[v]) {
                key[v] = graph[u][v];
            }
        }
    }

    cout &lt;&lt; "Total Cost of MST: " &lt;&lt; result &lt;&lt; "\n";
}

// Main Function
int main() {
    while (true) {
        cout &lt;&lt; "\nChoose an option:\n";
        cout &lt;&lt; "1. Optimal Tourist Routes\n";
        cout &lt;&lt; "2. Menu Item Sorting\n";
        cout &lt;&lt; "3. Traffic Monitoring\n";
        cout &lt;&lt; "4. Waste Management\n";
        cout &lt;&lt; "5. Water Usage Analysis\n";
        cout &lt;&lt; "6. Internet Connectivity Optimization\n";
        cout &lt;&lt; "7. Exit\n";

        int choice;
        cin &gt;&gt; choice;

        switch (choice) {
            case 1: optimalTouristRoutes(); break;
            case 2: menuItemSorting(); break;
            case 3: trafficMonitoring(); break;
            case 4: wasteManagement(); break;
            case 5: waterUsageAnalysis(); break;
            case 6: internetConnectivity(); break;
            case 7: return 0;
            default: cout &lt;&lt; "Invalid choice. Try again.\n";
        }
    }
    return 0;
}
    </code></pre>
     </section>
        
    <footer>
        <p>&copy; 2024 VAASTAV | Designed by Students of KLE Technological University.</p>
    </footer>
</body>
</html>
